// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.nordicstorm.robotics.subsystems;
 
import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.can.*;
import edu.wpi.first.wpilibj.command.PIDSubsystem;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import org.nordicstorm.robotics.RobotMap;
import org.nordicstorm.robotics.commands.*;
 
/**
 * DriveTrain for the 2013 Nordic Storm Ultimate Ascent Robot
 */
public class DriveTrain extends PIDSubsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    Gyro gyro = RobotMap.driveTrainGyro;
    CANJaguar _leftFrontMotor = RobotMap.driveTrain_leftFrontMotor;
    CANJaguar _rightFrontMotor = RobotMap.driveTrain_rightFrontMotor;
    CANJaguar _leftRearMotor = RobotMap.driveTrain_leftRearMotor;
    CANJaguar _rightRearMotor = RobotMap.driveTrain_rightRearMotor;
    Ultrasonic ultrasonic = RobotMap.driveTrainUltrasonic;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public final int ROTATE_TO_ANGLE_MODE = 1;
    public final int DRIVE_TO_ANGLE_MODE = 2;
    public final int DRIVE_TO_DISTANCE_MODE = 3;
    private RobotDrive m_robotDrive = RobotMap.driveTrainRobotDrive;
    private boolean m_voltageMode = false;
    private double m_pidDriveSpeed = 8.0;
    private int m_pidMode = 1;
    
    
    private class VelocityController extends PIDSubsystem{
        private double m_lastTime;
        private double m_lastDistance;
        private double m_total;
        private double m_timeZero;
        public VelocityController(){
            super(0.1,0,0);
            LiveWindow.addActuator("DriveTrain", "PIDVelocity Controller", getPIDController());
            getPIDController().setOutputRange(-12, 12);
            m_lastTime = Timer.getFPGATimestamp();
            m_lastDistance = getDistance();
            SmartDashboard.putNumber("Rate", 0);
        }
        protected double returnPIDInput() {
            double currentTime = Timer.getFPGATimestamp();
            double distance = getDistance();
            double retVal = 0;
            if(currentTime - m_lastTime > 1){
                retVal = getSetpoint();
                m_timeZero = currentTime;
                m_total = 0;
            }else{
                retVal = (m_lastDistance - distance)/(m_lastTime - currentTime);
            }
            m_lastTime = currentTime;
            m_lastDistance = distance;
            SmartDashboard.putNumber("Rate", retVal);
            return retVal;
           
        }
        
        public void disable(){
            getPIDController().disable();
            SmartDashboard.putNumber("Rate", 0);
        }
        protected void usePIDOutput(double output) {
            if(getSetpoint() < 0 && output > 0){
                output = 0;
            }
            if(getSetpoint() > 0 && output < 0){
                output = 0;
            }
            voltageDrive(output, output);
        }
        protected void initDefaultCommand() {
        }
        
    }
    
    private VelocityController m_velocityPid;
    /**
     * Initialize your subsystem here.
     */
    public DriveTrain() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
        super("DriveTrain", 0.125, 0.0, 0.0);
        setAbsoluteTolerance(0.2);
        getPIDController().setContinuous(false);
        LiveWindow.addActuator("DriveTrain", "PIDSubsystem Controller", getPIDController());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
        this.setPidMode(DRIVE_TO_ANGLE_MODE);
        ultrasonic.setAutomaticMode(true);
        ultrasonic.setEnabled(true);
        
        m_velocityPid = new VelocityController();
        
        // Use these to get going:
        // setSetpoint() -  Sets where the PID controller should move the system
        //                  to
        // enable() - Enables the PID controller.
    }
    
    /**
     * Set the default command for a subsystem here.
     */
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new DriveRobot());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    }
    
    /**
     * Drive in VBus mode.
     */
    public void drive(double leftValue, double rightValue) {
        setVBusMode();
        m_robotDrive.tankDrive(leftValue, rightValue);
    }
    
    /**
     * Drive using RobotDrive's arcadeDrive method.
     */
    public void arcadeDrive(GenericHID moveStick, final int moveAxis,
            GenericHID rotateStick, final int rotateAxis,
            boolean squaredInputs) {
        
        setVBusMode();
        m_robotDrive.arcadeDrive(moveStick, moveAxis, rotateStick, rotateAxis, squaredInputs);
    }
    
    /**
     * Drive in Voltage mode.
     */
    public void voltageDrive(double leftValue, double rightValue) {
        
        setVoltageMode();
        m_robotDrive.tankDrive((leftValue / 12.0), (rightValue / 12.0));
    }
    
    /**
     * Set the motors into Voltage mode
     */
    private void setVoltageMode() {
        if (!m_voltageMode) {
            
            if(m_robotDrive != null) {
                m_robotDrive.setMaxOutput(12);
            }
            
            try {
                if (_leftFrontMotor != null) {
                    _leftFrontMotor.changeControlMode(CANJaguar.ControlMode.kVoltage);
                    _leftFrontMotor.configNeutralMode(CANJaguar.NeutralMode.kBrake);
                }
                _leftRearMotor.changeControlMode(CANJaguar.ControlMode.kVoltage);
                _leftRearMotor.configNeutralMode(CANJaguar.NeutralMode.kBrake);
                
                
                if (_rightFrontMotor != null) {
                    _rightFrontMotor.changeControlMode(CANJaguar.ControlMode.kVoltage);
                    _rightFrontMotor.configNeutralMode(CANJaguar.NeutralMode.kBrake);                    
                }
                _rightRearMotor.changeControlMode(CANJaguar.ControlMode.kVoltage);
                _rightRearMotor.configNeutralMode(CANJaguar.NeutralMode.kBrake);
                
                
                if (_leftFrontMotor != null) {
                    _leftFrontMotor.enableControl();
                }
                _leftRearMotor.enableControl();
                
                if (_rightFrontMotor != null) {
                    _rightFrontMotor.enableControl();
                }
                _rightRearMotor.enableControl();
                
                m_voltageMode = true;
                
            } catch (CANTimeoutException ex) {
                System.out.println("DriveTrain::setVoltageMode - " + ex.getMessage());
            }
        }
    }
    
    /**
     * Set the motors into VBus mode.
     */
    private void setVBusMode() {
        if (m_voltageMode) {
            
            if(m_robotDrive!= null) {
                m_robotDrive.setMaxOutput(1);
            }
            
            try {
                if (_leftFrontMotor != null) {
                    _leftFrontMotor.changeControlMode(CANJaguar.ControlMode.kPercentVbus);
                    _leftFrontMotor.configNeutralMode(CANJaguar.NeutralMode.kCoast);                    
                }
                _leftRearMotor.changeControlMode(CANJaguar.ControlMode.kPercentVbus);
                _leftRearMotor.configNeutralMode(CANJaguar.NeutralMode.kCoast);                    
               
                if (_rightFrontMotor != null) {
                    _rightFrontMotor.changeControlMode(CANJaguar.ControlMode.kPercentVbus);
                    _rightFrontMotor.configNeutralMode(CANJaguar.NeutralMode.kCoast);                                        
                }
                _rightRearMotor.changeControlMode(CANJaguar.ControlMode.kPercentVbus);
                _rightRearMotor.configNeutralMode(CANJaguar.NeutralMode.kCoast);                    
                
                if (_leftFrontMotor != null) {
                    _leftFrontMotor.enableControl();
                }
                _leftRearMotor.enableControl();
                
                if (_rightFrontMotor != null) {
                    _rightFrontMotor.enableControl();
                }
                _rightRearMotor.enableControl();
                
                m_voltageMode = false;
            } catch (CANTimeoutException ex) {
                System.out.println("DriveTrain::setVBusMode - " + ex.getMessage());
            }
        }
    }
    
    /**
     * Update the SmartDashboard with the current status of
     * this subsystem. This is called repeatedly.
     */
    public void updateStatus() {
        try {
            if (_leftFrontMotor != null) {
                SmartDashboard.putNumber("Left Front Jaguar", _leftFrontMotor.getOutputVoltage());
                SmartDashboard.putNumber("Left Front Current", _leftFrontMotor.getOutputCurrent());                
            }
            SmartDashboard.putNumber("Left Rear Jaguar", _leftRearMotor.getOutputVoltage());
            SmartDashboard.putNumber("Left Rear Current", _leftRearMotor.getOutputCurrent());
            if (_rightFrontMotor != null) {
                SmartDashboard.putNumber("Right Front Jaguar", _rightFrontMotor.getOutputVoltage());
                SmartDashboard.putNumber("Right Front Current", _rightFrontMotor.getOutputCurrent());
            }
            SmartDashboard.putNumber("Right Rear Jaguar", _rightRearMotor.getOutputVoltage());
            SmartDashboard.putNumber("Right Rear Current", _rightRearMotor.getOutputCurrent());
        } catch (Exception ex) {
            System.out.println("DriveTrain::updateStatus - " + ex.getMessage());
        }
        
        SmartDashboard.putNumber("Ultrasonic", getDistance());
        SmartDashboard.putNumber("Gyro", this.gyro.getAngle());
        if (SmartDashboard.getBoolean("PrintDebug")) {
            //Put temporary print statements here, they can be turned off by
            //the PrintDebug checkbox on SmartDashboard
            System.out.println("Gyro = " + this.gyro.getAngle());
        }
    }
    
    /**
     * Return your input value for the PID loop
     * e.g. a sensor, like a potentiometer:
     *  yourPot.getAverageVoltage() / kYourMaxVoltage;
     */
    protected double returnPIDInput() {
        if(m_pidMode == DRIVE_TO_ANGLE_MODE || m_pidMode == ROTATE_TO_ANGLE_MODE){
            return gyro.getAngle();
        }else if (m_pidMode == DRIVE_TO_DISTANCE_MODE){
            return ultrasonic.getRangeInches();
        }
        return getSetpoint();
    }
    
    /**
     * Use the PID output to drive your system, like a motor.
     */
    protected void usePIDOutput(double output) {
        if (this.getPIDController().isEnable()) {
            if (m_pidMode == DRIVE_TO_ANGLE_MODE){
                voltageDrive(getPidDriveSpeed() + output, getPidDriveSpeed() - output);
            }else if(m_pidMode == ROTATE_TO_ANGLE_MODE){
                //voltageDrive(output, -output);
                double speed = getPidDriveSpeed();
                if(gyro.getAngle() > getSetpoint()){
                    speed = -speed;
                }
                voltageDrive(speed, -speed);
                System.out.println("Rotating to angle " + getSetpoint());
            }else if(m_pidMode == DRIVE_TO_DISTANCE_MODE){
                voltageDrive(output, output);
            }
            //System.out.println(Timer.getFPGATimestamp());
        }
    }
    
    /**
    * Stop the robot from driving.
    */
    public void stop() {
        m_robotDrive.tankDrive(0, 0);
    }
    public double getPidDriveSpeed() {
        return m_pidDriveSpeed;
    }
    public void setPidDrivespeed(double speed) {
        m_pidDriveSpeed = speed;
    }
    public void setPidMode(int newMode){
        m_pidMode = newMode;
        if (newMode==ROTATE_TO_ANGLE_MODE){
            getPIDController().setOutputRange(-12.0, 12.0);
            getPIDController().setPID(0.125, 0, 0);
            getPIDController().setAbsoluteTolerance(20);
        }else if(newMode == DRIVE_TO_ANGLE_MODE){
            getPIDController().setOutputRange(-4.0, 4.0);
            getPIDController().setPID(0.125, 0, 0);
            getPIDController().setAbsoluteTolerance(2);            
        }else if(newMode == DRIVE_TO_DISTANCE_MODE){
            getPIDController().setOutputRange(-8, 8.0);
            getPIDController().setPID(0.45, .013, 0.0);
            getPIDController().setAbsoluteTolerance(2);
        }
    }
    public double getLeftCurrent(){
        try {
            return _leftRearMotor.getOutputCurrent();
        } catch (CANTimeoutException ex) {
            ex.printStackTrace();
        }
        return 0;
    }
    public double getRightCurrent(){
        try {
            return _rightRearMotor.getOutputCurrent();
        } catch (CANTimeoutException ex) {
            ex.printStackTrace();
        }
        return 0;
    }
    
    public double getDistance(){
        return ultrasonic.getRangeInches();
    }
    
    public VelocityController getVelocityPid(){
        return m_velocityPid;
    }
    
    public void disable(){
        getPIDController().disable();
        m_velocityPid.disable();
    }
    
    public void setSetpointRelative(double setpoint){
        if(m_pidMode == DRIVE_TO_DISTANCE_MODE){
            super.setSetpoint(ultrasonic.getRangeInches());
            super.setSetpointRelative(setpoint);
        }else if(m_pidMode == DRIVE_TO_ANGLE_MODE || m_pidMode == ROTATE_TO_ANGLE_MODE){
            super.setSetpoint(gyro.getAngle());
            super.setSetpointRelative(setpoint);
        }
    }
}
