// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.nordicstorm.robotics.subsystems;
import edu.wpi.first.wpilibj.AnalogChannel;
import edu.wpi.first.wpilibj.CANJaguar;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.can.CANTimeoutException;
import edu.wpi.first.wpilibj.command.PIDSubsystem;
import org.nordicstorm.robotics.RobotMap;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
/**
 *
 */
public class Dumper extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    CANJaguar bucketMotor = RobotMap.dumperBucketMotor;
    CANJaguar armMotor = RobotMap.dumperArmMotor;
    AnalogChannel bucketPot = RobotMap.dumperBucketPot;
    AnalogChannel armPot = RobotMap.dumperArmPot;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    public class DumperSection extends PIDSubsystem{
        private CANJaguar m_motor;
        private AnalogChannel m_pot;
        private String m_name;
        private boolean m_reversed;
        private boolean m_slowDecent = false;
        private double m_peak = 0;
        private boolean m_useRate;
        private double m_lastReading;
        private double m_lastReadingTimestamp;
        
        public DumperSection(double P, double I, double D, CANJaguar motor, AnalogChannel pot, boolean reversedMotor,double peak, boolean useRate, String name){
            super(P,I,D);
            setAbsoluteTolerance(5);
            getPIDController().setContinuous(false);
            LiveWindow.addActuator(name, "PIDSubsystem Controller", getPIDController());
            
            m_reversed = reversedMotor;
            m_name = name;
            m_useRate=useRate;
            if (peak >= 0){
                m_slowDecent = true;
                m_peak = peak;
            }
            m_motor = motor;
            
            try {
                m_motor.changeControlMode(CANJaguar.ControlMode.kVoltage);
                m_motor.configNeutralMode(CANJaguar.NeutralMode.kBrake);
                m_motor.enableControl();
            } catch (CANTimeoutException ex) {
                ex.printStackTrace();
            }
            m_pot = pot;
        }
        protected double returnPIDInput() {
            double curVal= m_pot.getAverageValue();
            double retVal=curVal;
            if(m_useRate) {
                 double curTime=Timer.getFPGATimestamp();
                 if(curTime-m_lastReadingTimestamp>1) {
                     retVal=0;
                 }
                 else
                 {
                     retVal=(curVal-m_lastReading)/(Timer.getFPGATimestamp()-m_lastReadingTimestamp);
                 }
                 m_lastReadingTimestamp=curTime;
            }
            return retVal;
        }
        protected void usePIDOutput(double output) {
            if (m_motor == null){
                return;
            }
            if(m_reversed){
                output = -output;
            }
            double pot = getPot();
            //System.out.println("Raw Output = " + output);
            if(m_slowDecent){
                double setpoint = getSetpoint();
                boolean drivingUp = output > 0 && !m_reversed || output < 0 && m_reversed;
                if ((pot > m_peak && drivingUp)||(pot < m_peak && !drivingUp)){
                    output = output/2;
                    //System.out.println("Decending to setpoint " + setpoint);
                }else{
                    double base = output/2;
                    double dir = 1;
                    /*if (output < 0){
                        dir = -1;
                    }*/
                    //System.out.println(Math.abs(pot - m_peak)/500.0 + ", " + base + ", " + dir);
                    output = output*(Math.abs(pot - m_peak)/500.0) + base*dir;
                }
            }
            //System.out.println("PIDOutput " + output);
            //System.out.println("Peak: " + m_peak + " Pot: " + pot);
            try {
                m_motor.setX(output);
            } catch (CANTimeoutException ex) {
                ex.printStackTrace();
            }
        }
        protected void initDefaultCommand() {
        }
        
        public void driveMotor(double speed){
            try {
                if (m_motor.getControlMode() == CANJaguar.ControlMode.kVoltage){
                    speed = speed*12.0;
                }
                m_motor.setX(speed);
            } catch (CANTimeoutException ex) {
                ex.printStackTrace();
            }
        }
        
        public double getPot(){
            return m_pot.getAverageValue();
        }
        public void updateStatus(){
            SmartDashboard.putNumber(m_name + "Pot", m_pot.getAverageValue());
        }
        public void setPeak(double newPeak){
            m_peak = newPeak;
        }
        public void disable(){
            getPIDController().disable();
        }
        
    }
    
    
    public class RateDrivingPIDSubsystem extends PIDSubsystem {
        private PIDController m_controller;
        private AnalogChannel m_pot;
        
        public RateDrivingPIDSubsystem(double P, double I, double D, PIDController controller, AnalogChannel pot) {
            super(P,I,D);
            m_pot=pot;
            m_controller=controller;
        }     
        protected double returnPIDInput() {
            return m_pot.getAverageValue();
        }
        protected void usePIDOutput(double output) {
            m_controller.setSetpoint(output);
        }
        protected void initDefaultCommand() {
        }
    }
      
    private DumperSection m_bucket;
    private DumperSection m_arm;
    
    
    //Important values for the Dumper Arm, make sure to set the pot so the vertical one is accurate
    public final int ARM_VERTICAL = 186;
    public final int ARM_CARRYING = ARM_VERTICAL - 131;
    public final int ARM_LOAD = ARM_VERTICAL + 12;
    public final int ARM_EXTENDED = ARM_VERTICAL + 589;
    public final int ARM_WALL_DUMP = ARM_VERTICAL + 341;
    public final int ARM_PYRAMID_DUMP = ARM_VERTICAL + 423;
    
    
    //Important values for the Dumper Bucket, make sure to set the pot so the vertical one is accurate
    public final int BUCKET_VERTICAL = 491;
    public final int BUCKET_LOAD = BUCKET_VERTICAL + 153;
    public final int BUCKET_WALL_DUMP = BUCKET_VERTICAL + 310;
    public final int BUCKET_PYRAMID_DUMP = BUCKET_VERTICAL - 336;
    
    public Dumper(){
        m_bucket = new DumperSection(0.2,0.002,0.001,bucketMotor,bucketPot,true,-1,false,"DumperBucket");
        m_bucket.getPIDController().setOutputRange(-4.0, 4.0);
        m_bucket.getPIDController().setAbsoluteTolerance(10);
        
        m_arm  = new DumperSection(0.05,0.0,0.0,armMotor,armPot,false, ARM_VERTICAL,false,"DumperArm");
        m_arm.getPIDController().setOutputRange(-6.0, 6.0);
        //m_bucket.setSetpoint(BUCKET_VERTICAL);
        //m_bucket.enable();
        //m_arm.setSetpoint(ARM_VERTICAL;);
        //m_arm.enable();
    }
    
    public DumperSection getArm(){
        return m_arm;
    }
    public DumperSection getBucket(){
        return m_bucket;
    }
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    
    public boolean allOnTarget(){
        return m_arm.onTarget() && m_bucket.onTarget();
    }
    
    public void updateStatus(){
        m_arm.updateStatus();
        m_bucket.updateStatus();
    }
            
}
