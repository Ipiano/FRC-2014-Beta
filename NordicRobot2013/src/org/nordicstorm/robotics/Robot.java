// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.nordicstorm.robotics;
import com.sun.squawk.util.MathUtils;
import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.Preferences;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import org.nordicstorm.robotics.commands.*;
import org.nordicstorm.robotics.subsystems.*;
    
/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the IterativeRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 */
public class Robot extends IterativeRobot {
    // Operator Interface
    public static OI oi;
    
    // Autonomous command
    private Command autonomousCommand;
    
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static DriveTrain driveTrain;;
    public static Vision vision;
    public static ClimberActuator climberActuator;;
    public static RatchetClimber ratchetClimber;
    public static Dumper dumper;
    public static PES pES;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    // Stuff for the cRIO response times
    private Timer m_timer = new Timer();
    private double m_totalTime;
    private int m_timeTicker;
    public static double _gyroTarget = 0;
    public static double _bottomPixel = 0;
    public static double _topPixel = 0;
    private static boolean m_climberIsCalibrated;
    
    // SmartDashboard items
    private SendableChooser m_driveTypes;
    
    //Default Autonomous Code; Will run if there is a comm error with the computer, but not the FMS
    public static String autonomousDefault = "D 1,-7,-7;G 10,-9,120,-0.7;S;PA;F;D .5,6,6;Y 2,-7,140;Y 2,-10,0;X .5;";
    private String m_lastAutonomousMode;
    
    
    /**
     * This function is run when the robot is first started up and should be
     * used for any initialization code.
     */
    public void robotInit() {
        RobotMap.init();
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        driveTrain = new DriveTrain();
        vision = new Vision();
        climberActuator = new ClimberActuator();
        ratchetClimber = new RatchetClimber();
        dumper = new Dumper();
        pES = new PES();
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        
        // This MUST be here. If the OI creates Commands (which it very likely
        // will), constructing it during the construction of CommandBase (from
        // which commands extend), subsystems are not guaranteed to be
        // yet. Thus, their requires() statements may grab null pointers. Bad
        // news. Don't move it.
        oi = new OI();
        // instantiate the command used for the autonomous period
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
        autonomousCommand = new Autonomous();
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
        m_climberIsCalibrated = false;
        initializeSmartDashboard();
        m_lastAutonomousMode = Preferences.getInstance().getString("AutonomousCommand", autonomousDefault);
    }
    
    /**
     * Code which will be called each time
     * the robot enters autonomous mode.
     */
    public void autonomousInit() {
        // schedule the autonomous command (example)
        if (autonomousCommand != null) {
            autonomousCommand.start();
        }
    }
    
    /**
     * This function is called periodically during autonomous.
     */
    public void autonomousPeriodic() {
        Scheduler.getInstance().run();
        updateStatus(); // Update SmartDashboard
    }
    
    /**
     * Initialization code which will be called each time
     * the robot enters teleop mode.
     */
    public void teleopInit() {
        
        //Reset cRIO timer
        m_timer.reset();
        m_timer.start();
        m_timeTicker = 0;
        m_totalTime = 0.0;
        // This makes sure that the autonomous stops running when
        // teleop starts running. If you want the autonomous to 
        // continue until interrupted by another command, remove
        // this line or comment it out.
        if (autonomousCommand != null) {
            autonomousCommand.cancel();
        }
    }
    
    /**
     * This function is called periodically during operator control.
     */
    public void teleopPeriodic() {
        
        // time the cRIO performance if checkbox checked on SmartDashboard
        //if (SmartDashboard.getBoolean("TimeCrio")) {
            timeCrio();
        //}
        
        // get the drive type from the SmartDashboard and set it on OI
        Integer driveType = (Integer)m_driveTypes.getSelected();
        oi.setDriveType(driveType.intValue());
        
        Scheduler.getInstance().run();
        updateStatus();
    }
    
    public void testInit(){
        Robot.driveTrain.getPIDController().reset();
    }
    
    /**
     * This function called periodically during test mode.
     */
    public void testPeriodic() {
        LiveWindow.run();
        updateStatus();
    }
    
    /**
     * Code which will be called periodically at a regular
     * rate while the robot is in disabled mode.
     */
    public void disabledPeriodic(){
        updateStatus();
        if (!Preferences.getInstance().getString("AutonomousCommand", autonomousDefault).equals(m_lastAutonomousMode)){
            autonomousCommand = new Autonomous();
            SmartDashboard.putData("Autonomous", new Autonomous());
            m_lastAutonomousMode = Preferences.getInstance().getString("AutonomousCommand", autonomousDefault);
        }
        endPids();
    }
    
    /**
     * Update the SmartDashboard.
     */
    private void updateStatus() {
        if (RobotMap.driveTrain_leftRearMotor != null){
            Robot.driveTrain.updateStatus();
        }
        Robot.oi.updateStatus();
        if (RobotMap.ratchetClimberRatchet != null){
            Robot.ratchetClimber.updateStatus();
        }
        Robot.climberActuator.updateStatus();
        
        if (Robot.dumper != null) {
            Robot.dumper.updateStatus();
        }
        
    }
    
    /**
     * Update timing statistics for the cRIO.
     */
    private void timeCrio() {
        double newTime = m_timer.get();
        SmartDashboard.putNumber("cRIO Timer", newTime);
        m_timeTicker++;
        m_totalTime = m_totalTime + newTime;
        SmartDashboard.putNumber("cRIO Average", m_totalTime / m_timeTicker);
        m_timer.reset();
        m_timer.start();
        System.out.println("cRIO timing: " + m_totalTime/m_timeTicker);
    }
    
    /**
     * Put controls on the SmartDashboard.
     */
    private void initializeSmartDashboard() {
        m_driveTypes = new SendableChooser();
        m_driveTypes.addDefault("Twist mode", new Integer(RobotMap.DRIVE_ARCADE));
        m_driveTypes.addObject("Tank mode", new Integer(RobotMap.DRIVE_TANK));
        m_driveTypes.addObject("Custom mode", new Integer(RobotMap.DRIVE_TWIST));
        SmartDashboard.putData("Drive mode", m_driveTypes);
        
        SmartDashboard.putBoolean("TimeCrio", false);
        SmartDashboard.putBoolean("PrintDebug", false);
        
        createPreferences();
    }
    
    /*
     * Make sure preferences used are in the Preferences file
     */
    
    private void createPreferences(){
        Preferences pref = Preferences.getInstance();
        if (!pref.containsKey("AutonomousCommand")){
            pref.putString("AutonomousCommand", autonomousDefault);
        }
        if (!pref.containsKey("ActuatorVertical")){
            pref.putInt("ActuatorVertical", 270);
	}
        if (!pref.containsKey("MaxTurnSpeed")){
            pref.putDouble("MaxTurnSpeed", 0.8);
        }
        
        pref.save();
             
    }
    public static void setCalibration(boolean isDone){
        m_climberIsCalibrated = isDone;
    }
    public static boolean getCalibration(){
        return m_climberIsCalibrated;
    }
    
 
    private void endPids(){
        Robot.driveTrain.disable();
        if (Robot.dumper != null) {
            Robot.dumper.getArm().disable();
            Robot.dumper.getBucket().disable();
        }
        Robot.climberActuator.disable();
    }
}
